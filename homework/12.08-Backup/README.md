# Домашнее задание к занятию "Резервное копирование" - Пешева Ирина


### Задание 1. Резервное копирование

Финансовая компания решила увеличить надёжность работы баз данных и их резервного копирования.

Необходимо описать, какие варианты резервного копирования подходят в случаях:

1.1. Необходимо восстанавливать данные в полном объёме за предыдущий день.

1.2. Необходимо восстанавливать данные за час до предполагаемой поломки.

1.3.* Возможен ли кейс, когда при поломке базы происходило моментальное переключение на работающую или починенную базу данных.

Приведите ответ в свободной форме.

### Решение 1

#### Необходимо восстанавливать данные в полном объёме за предыдущий день

В таком случае можно делать полный бэкап каждый день – восстановление пройдёт быстрее и проблем с таким бэкапом быть не должно. Разве что место занимает, но если другие дни не требуются, одну полную копию можно пережить.

#### Необходимо восстанавливать данные за час до предполагаемой поломки.

Каждый час делать полную копию накладно. И даже дифференциальную. Надо что-то, что будет быстро создавать копии, не сильно долго этим заниматься и занимать поменьше места.

В таком случае подойдут инкрементные бэкапы, записывающие изменения с момента последнего бэкапа.

#### Возможен ли кейс, когда при поломке базы происходило моментальное переключение на работающую или починенную базу данных.

Если проблема с доступностью, то спасти может всё, что создаёт какую-никакую копию данных – репликация (нагрузку примут оставшиеся slave или master), RAID, DRBD, SAN-кластера.

Однако же, если что-то сломало саму базу данных, это могло произойти на всех копиях, и тут как будто только откатываться до последнего сохранённого бэкапа.

---
### Задание 2. PostgreSQL

2.1. С помощью официальной документации приведите пример команды резервирования данных и восстановления БД (pgdump/pgrestore).

2.1.* Возможно ли автоматизировать этот процесс? Если да, то как?

Приведите ответ в свободной форме.

### Решение 2

#### Резервирование и восстановление данных в PostgreSQL

Выгрузка в виде скрипта (plain)

```shell
pg_dump <database_name> > <script_name>.sql
```
или то же самое
```shell
pg_dump -Fp <database_name> > <script_name>.sql
```

Выгрузка в виде специального файла (custom):

```shell
pg_dump -Fc <database_name> > <file_name>.dump
```

Выгрузка в виде каталога:

```shell
pg_dump -Fd <database_name> -f <dirname>
```

Выгрузка в виде tar-архива:

```shell
pg_dump -Ft <database_name> -f <tar_name>.tar
```

Все указанные форматы приходны для восстановления через pg_restore.

Восстановление:

```shell
pg_restore -d <database_name> <file_name>
```
При этом база данных уже должна быть создана, но быть пустой.


#### Автоматизация резервирования

Походит любая утилита, позволяющая задать время исполнения.
* средствами Linux это можно сделать с помощью crontab;
* конкретно для PosgreSQL можно использовать pgAgent – его потребуется установить в качестве расширения, запустить как демона и задать расписание.

---
### Задание 3. MySQL

3.1. С помощью официальной документации приведите пример команды инкрементного резервного копирования базы данных MySQL.

3.1.* В каких случаях использование реплики будет давать преимущество по сравнению с обычным резервным копированием?

Приведите ответ в свободной форме.

### Решение 3

#### Инкрементное резервное копирование БД MySQL

MySQL Enterprise просто предлагает использовать инструмент mysqlbackup; тогда команда будет выглядеть как:

```shell
mysqlbackup --defaults-file=/home/dbadmin/my.cnf \
  --incremental --incremental-base=history:last_backup \
  --backup-dir=<path_to_backup> \
  --backup-image=<image_file_name>.bi \
   backup-to-image
```

Если же мы использовать mysqlbackup не можем и имеем под рукой только mysqldump, то алогиртм становится сложнее. Он предполагает использование binary logs – логов о событиях в БД.

Сначала делаем полный бэкап, и затем записываем инкрементные изменения через фиксацию логов. 

```shell
mysqldump -uroot -p --all-databases --single-transaction --flush-logs --master-data=2 > <full_backup_name>.sql
```

Здесь ключевой параметр – --flush-logs, который закрывает запись логов в старый файл и открывает новый. При создание следующего "инкремента" нужно будет также "закрыть" новый файл и "открыть" новый.

```shell
mysqladmin -uroot -p flush-logs
```

При восстановлении данных понадобится также сначала восстановить изначальный полный бэкап, созданный с помощью mysqldump:

```shell
mysql -u root -p mydb < <full_backup_name>.sql
```

Затем последовательно применить все binary logs:

```shell
mysqlbinlog /var/log/mysql/mysql-bin.<number_of_log> | mysql -uroot -p mydb
```

#### Когда лучше реплика, чем резервное копирование

Если проблема не в том, что какие-то данные поломали таблицы или базу данных целиком, а в доступе к данным, реплика позволит достаточно быстро переключить соединения; потеря данных при этом будет минимальной.

---
